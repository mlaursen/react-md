import { type ChangeEventHandler, type DragEventHandler } from "react";

/** @since 2.9.0 */
export interface BaseFileUploadStats {
  /**
   * A unique key associated with each upload generated by `nanoid`.
   */
  key: string;

  /**
   * The file instance that is being uploaded.
   */
  file: File;

  /**
   * The current upload progress as a percentage from 0 - 100 percent.
   */
  progress: number;
}

/** @since 2.9.0 */
export interface ProcessingFileUploadStats extends BaseFileUploadStats {
  status: "pending" | "uploading";
}

/** @since 2.9.0 */
export type FileReaderResult = FileReader["result"];

/** @since 2.9.0 */
export interface CompletedFileUploadStats extends BaseFileUploadStats {
  status: "complete";

  /**
   * The result after a `FileReader` has read a file completely.
   *
   * Note: This _should_ be an `ArrayBuffer` if the next step is to upload to a
   * server.
   *
   * @see {@link FileReaderParser}
   * @see {@link getFileParser}
   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/FileReader | FileReader}
   */
  result: FileReaderResult;
}

/** @since 2.9.0 */
export type FileUploadStats =
  | ProcessingFileUploadStats
  | CompletedFileUploadStats;

/** @since 2.9.0 */
export type FileUploadStatus = FileUploadStats["status"];

/** @since 2.9.0 */
export interface FileUploadHandlers<E extends HTMLElement> {
  onDrop?: DragEventHandler<E>;
  onChange?: ChangeEventHandler<HTMLInputElement>;
}

/**
 * This will first check if the mime-type of the file starts with `text/` and
 * fallback to checking a few file names or extensions that should be considered
 * text.
 *
 * This function is not guaranteed to be 100% correct and is only useful if
 * trying to generate a preview of files uploaded to the browser.
 *
 * @param file - The file to check
 * @returns `true` if the file should be considered as a text-content file.
 * @since 2.9.0
 */
export function isTextFile(file: File): boolean {
  return /\.((j|t)sx?|json|lock|hbs|ya?ml|log|txt|md)$/i.test(file.name);
}

/**
 * This will first check if the mime-type of the file starts with `text\/` and
 * fallback to checking a few file names or extensions that should be considered
 * text.
 *
 * This function is not guaranteed to be 100% correct and is only useful if
 * trying to generate a preview of files uploaded to the browser.
 *
 * @param file - The file to check
 * @returns `true` if the file should be considered as a text content file.
 * @since 2.9.0
 */
export function isImageFile(file: File): boolean {
  return /\.(a?png|avif|svg|tiff|gifv?|jpe?g)/i.test(file.name);
}

/**
 * This will first check if the mime-type of the file starts with `audio/` and
 * fallback to checking a few file names or extensions that should be considered
 * audio.
 *
 * This function is not guaranteed to be 100% correct and is only useful if
 * trying to generate a preview of files uploaded to the browser.
 *
 * @param file - The file to check
 * @returns `true` if the file should be considered as a audio content file.
 * @since 2.9.0
 */
export function isAudioFile(file: File): boolean {
  return /\.(mp3|wav|ogg|m4p|flac)$/i.test(file.name);
}

/**
 * This will first check if the mime-type of the file starts with `video/` and
 * fallback to checking a few file names or extensions that should be considered
 * video.
 *
 * This function is not guaranteed to be 100% correct and is only useful if
 * trying to generate a preview of files uploaded to the browser.
 *
 * @param file - The file to check
 * @returns `true` if the file should be considered as a video content file.
 * @since 2.9.0
 */
export function isVideoFile(file: File): boolean {
  return /\.(mkv|mpe?g|mov|avi|flv|webm|mp4)$/i.test(file.name);
}

/**
 * This function is not guaranteed to be 100% correct and is only useful if
 * trying to generate a preview of files uploaded to the browser.
 *
 * @param file - The file to check
 * @returns `true` if the file matches an image, audio, or video file.
 * @since 2.9.0
 */
export function isMediaFile(file: File): boolean {
  return isImageFile(file) || isAudioFile(file) || isVideoFile(file);
}

/**
 * One of the function names from a `FileReader` to upload a file to the
 * client.
 *
 * Note: If this file does not need to be previewed in the browser and will
 * immediately be uploaded to a server, use `readAsArrayBuffer`.
 *
 * @since 2.9.0
 * @since 6.0.0 Removed `"readAsBinaryString` since it is deprecated
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/FileReader/readAsBinaryString}
 */
export type FileReaderParser =
  | "readAsText"
  | "readAsDataURL"
  | "readAsArrayBuffer";

/**
 * A function that should return one of the {@link FileReaderParser} functions
 * to start uploading a file to the browser.
 *
 * @example The Default File Upload Parser
 * ```ts
 * export const getFileParser: GetFileParser = (file) => {
 *   if (isMediaFile(file)) {
 *     return "readAsDataURL";
 *   }
 *
 *   if (isTextFile(file)) {
 *     return "readAsText";
 *   }
 *
 *   return "readAsArrayBuffer";
 * };
 * ```
 *
 * @param file - The file to get a parser for
 * @returns the {@link FileReaderParser} string.
 * @since 2.9.0
 */
export type GetFileParser = (file: File) => FileReaderParser;

/**
 * This function will attempt to read:
 * - media (image, audio, and video) files as a data url so they can be
 *   previewed in `<img>`, `<audio>`, and `<video>` tags
 * - text files as plain text
 * - everything else as an `ArrayBuffer` which can be manually converted into a
 *   data url if needed with `URL.createObjectURL`
 *
 * @since 2.9.0
 */
export const getFileParser: GetFileParser = (file) => {
  if (isMediaFile(file)) {
    return "readAsDataURL";
  }

  if (isTextFile(file)) {
    return "readAsText";
  }

  return "readAsArrayBuffer";
};

/** @since 2.9.0 */
export interface SplitFileUploads {
  readonly pending: readonly ProcessingFileUploadStats[];
  readonly uploading: readonly ProcessingFileUploadStats[];
  readonly complete: readonly CompletedFileUploadStats[];
}

/**
 * This util will split all the current upload stats by status.
 *
 * @example Main Usage
 * ```tsx
 * import { FileUpload } from "@react-md/core/files/FileUpload";
 * import { useFileUpload } from "@react-md/core/files/useFileUpload";
 * import { getSplitFileUploads } from "@react-md/core/files/utils";
 *
 * function Example() {
 *   const { stats, errors, accept, onChange } = useFileUpload();
 *   const { pending, uploading, completed } = getSplitFileUploads(stats);
 *
 *   return (
 *     <>
 *       <FileUpload accept={accept} onChange={onChange} />
 *       {pending.map(({ key, file, progress, status }) => {
 *         // pretend some UI for each pending item with the provided data
 *         return null;
 *       })}
 *       {uploading.map(({ file, key, progress, status }) => {
 *         // pretend some UI for each uploading item with the provided data
 *         return null;
 *       })}
 *       {complete.map(({ file, key, progress, result, status }) => {
 *         // pretend some UI for each complete item with the provided data
 *         return null;
 *       })}
 *     </>
 *   );
 * }
 * ```
 *
 * @param stats - The {@link FileUploadStats} list generally returned by the
 * {@link useFileUpload} hook.
 * @returns the {@link SplitFileUploads}.
 * @since 2.9.0
 */
export function getSplitFileUploads(
  stats: readonly FileUploadStats[]
): SplitFileUploads {
  const pending: ProcessingFileUploadStats[] = [];
  const uploading: ProcessingFileUploadStats[] = [];
  const complete: CompletedFileUploadStats[] = [];
  for (const stat of stats) {
    switch (stat.status) {
      case "pending":
        pending.push(stat);
        break;
      case "uploading":
        uploading.push(stat);
        break;
      case "complete":
        complete.push(stat);
        break;
      default:
        /* istanbul ignore next */
        throw new Error("Invalid upload stat");
    }
  }

  return { pending, uploading, complete };
}
